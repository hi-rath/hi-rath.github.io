## 第3章 字符串、向量和数组

### 3.1 命名空间using声明

- using声明就无须专门的前缀（形如命名空间::)也能使用所需的名字了

- using声明具有如下的形式：

  ```c++
  using namespace::name;
  ```

- 一旦声明了上述语句，就可以直接访问命名空间中的名字：

  ```c++
  #include<iostream>
  using std::cin;
  
  int main()
  {
  	int i;
  	cin>>i;
  }
  ```

- 每个名字都需要独立的using声明

##### 头文件不应包含using声明

- 这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。会产生名字冲突

### 3.2 标准库类型string

#### 3.2.1 定义和初始化string对象

- 初始化string对象的方式

  ```c++
      string s1;          // 默认初始化，s1是一个空串
      string s2(s1);      // s2是s1的副本
      string s3 = s1;     // 等价于s2(s1)，s2是s1的副本
      string s4("value"); // s4是字面值"value"的副本，除了字面值最后的那个空字符外
      string s5 = "value";// 等价于s4("value")，s5是字面值"value"的副本
      string s6(n, 'c');  // 把s6初始化为由连续n个字符c组成的串
  ```

##### 直接初始化和拷贝初始化

- 如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化**，编译器把等号右侧的初始值拷贝到新创建的对象中去。

- 与之相反，如果不使用等号，则执行的是**直接初始化**

  - 当初始值只有一个时，使用直接初始化或拷贝初始化都行。

  - 如果像上面的s6那样初始化要用到的值有多个，一般来说只能使用直接初始化的方式：

    ```c++
    string s5="hiya";		//拷贝初始化
    string s6("hiya");		//直接初始化
    string s7(10,'c');		//直接初始化，s7的内容是cccccccccc
    ```

  - 对于用多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需要显式地创建一个（临时）对象用于拷贝：

    ```c++
    string s8=string(10,'c');	//拷贝初始化，s8的内容是cccccccccc
    ```

#### 3.2.2 string对象上的操作

##### 读写string对象

- 使用IO操作符读写string对象：

  ```c++
  int main()
  {
  	string s;
  	cin>>s;
  	cout<<s<<endl;
  	return 0;
  }
  ```

- 定义一个名为s的空string，然后将标准流的内容读取到s中。

- string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。

- 如果程序的输入是“   Hello World!     ”,则输出将是“Hello”，输出结果中没有任何空格。

##### 读取未知数量的string对象

- 使用`Ctrl+z`，然后`Enter`结束，文件结束符

```c++
int main()
{
    int n = 10;
    string word;
    while (cin>>word)
    {
        cout<<word<<endl;
    }
    return 0;
}
```

##### 使用getline读取一整行

- 有时我们希望在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的>>运算符。
- getline函数的参数为一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。
- getline只要一遇到换行符就结束读取操作并返回结果。

```c++
int main()
{
	string line;
	while (getline(cin,line))
	{
		cout<<line<<endl;
	}
	return 0;
}
```

##### string::size_type类型

- 对于size函数来说，返回一个int或者一个unsigned似乎都是合情合理的。但其实size函数返回的是一个string::size_type类型的值。
- 它是一个无符号类型的值，而且能够足够放下任何string对象的大小。

##### 比较string对象

- 使用关系运算符<、<=、>、>=分别检验一个string对象，且大小写敏感。

##### 两个string对象相加

- 对string对象使用加法运算符(+)的结果是一个新的string对象。
- 复合赋值运算符(+=)负责把右侧string对象的内容追加到左侧string对象的后面。

##### 字面值和string对象相加

- 当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个string对象。不能把字面值直接相加。
- **切记，字符串字面值与string是不同的类型**。

#### 3.2.3 处理string对象中的字符

- 单独处理string对象中的字符。
- cctype头文件中定义了一组标准库函数处理这部分工作

| 函数        | 含义                                               |
| ----------- | -------------------------------------------------- |
| isalnum(c)  | 当c是字母或数字时为真                              |
| isalpha(c)  | 当c是字母时为真                                    |
| iscntrl(c)  | 当c是控制字符时为真                                |
| isdigit(c)  | 当c是数字时为真                                    |
| isgraph(c)  | 当c不是空格但可打印时为真                          |
| islower(c)  | 当c是小写字母时为真                                |
| ispunct(c)  | 当c是标点符号时为真                                |
| isspace(c)  | 当c是空白时为真                                    |
| isupper(c)  | 当c是大写字母时为真                                |
| isxdigit(c) | 当c是十六进制数字为真                              |
| tolower(c)  | 如果c是大写字母，输出对应的小写字母；否则原样输出c |
| toupper(c)  | 如果c是小写字母，输出对应的大写字母；否则原样输出c |

> C++标准库中除了定义C++语言特有的功能外,也兼容了C语言的标准库.C语言的头文件形如name.h,C++则将这些文件命名为cname.也就是去掉了.h后缀,而在文件名name之前添加了字母c

##### 范围for语句

- C++11新标准提供了一种语句:范围for语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：

  ```c++
  for (declaration:expression)
  	statement
  ```

- 可以使用范围for语句把string对象中的字符每行一个输出出来：

  ```c++
  string str("some string");
  for (auto c:str)
  	cout<<c<<endl;
  ```

- 通过使用auto关键字让编译器来决定变量c的类型，这里c的类型是char。每次迭代，str的下一个字符将被拷贝到c。

##### 使用范围for语句改变字符串中的字符

- 当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。

```c++
   string s("Hello World!!!");
   for (auto &c: s)
        c = toupper(c);
    cout<<s<<endl;
```

- 每次迭代时，变量c引用string对象s的下一个字符，赋值给c也就是在改变s中对应字符的值。因此当执行下面的语句时，

  ```
  c = toupper(c);		//c是一个引用，因此赋值语句将改变s中字符的值
  ```

  实际上改变了c绑定的字符的值。整个循环结束后，str中的所有字符都变成了大写形式。

##### 只处理一部分字符?

- 要想访问string对象中的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器（后面介绍）。

- **下标运算符([ ])**接收的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置：返回值是该位置上字符的引用。

- 使用下标执行迭代：

  ```c++
      string s("some thing");
      for (decltype(s.size()) index = 0;index!=s.size()&&!isspace(s[index]);++index)
          s[index] = toupper(s[index]);
      cout<<s<<endl;
  ```

  - for语句的条件使用了逻辑与运算符(&&)。**C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况**。如此例所示，这条规定确保了只有当下标取值在合理范围之内才会真的用此下标去访问字符串。

### 3.3 标准库类型vector

- vector表示对象的集合，其中所用对象的类型都相同。它能容纳着其他对象，所以它也常被称为容器。

- C++语言既有类模板，也有函数模板，vector是一个类模板。

- 模板本身不是类或函数，相反可以将模板看作编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

  - 对于类模板来说，实例化类型是在模板名字后面跟一对尖括号，在括号内放上类型信息。

    ```c++
    vector<int> ivec;		//ivec保存int类型的对象
    vector<vector<string>> file;//该向量的元素是vector对象
    ```

#### 3.3.1 定义和初始化vector对象

| 代码                      | 含义                                                    |
| ------------------------- | ------------------------------------------------------- |
| `vector<T> v1`            | v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 |
| `vector<T> v2(v1)`        | v2中包含有v1所有元素的副本                              |
| `vector<T> v3(n,val)`     | v3包含了n个重复的元素，每个元素的值都是val              |
| `vector<T> v4(n)`         | v4包含了n个重复地执行了值默认初始化的对象               |
| `vector<T> v5{a,b,c,..}`  | v5包含了初始值个数的元素，每个元素被赋予相应的初始值    |
| `vector<T> v5={a,b,c,..}` | 等价于v5{a,b,c,...}                                     |

##### 列表初始化vector对象

- 用花括号括起来的0个或多个初始元素值被赋给vector对象：

  ```c++
  vector<string> articles={"a","an","the"};
  ```

  - 使用拷贝初始化时（即使用=时）只能提供一个初始值

  - 提供类内初始值，则只能使用拷贝初始化或使用话空号的形式初始化。

  - 提供的是初始元素的列表，则只能使用花括号进行列表初始化，而不能放在圆括号里：

    ```c++
    vector<string> v1{"a","an"};//列表初始化
    vector<string> v2("a","an");//错误
    ```

##### 值初始化

- 只创建元素数量而不管初始值，此时库会默认初始化这些值。

- 这个初值由vector对象中元素的类型决定：

  - 如果是内置类型，比如int，则元素初始值自动设为0
  - 如果是某种类类型，比如string，则元素由类默认初始化

  ```c++
  vector<int> ivec(10);		//10个元素，每个都初始化为0
  vector<string> svec(10);	//10个元素，每个都是空string对象
  ```

- 这种初始化的方式有两个特殊限制：

  1. 有些类必须明确地提供初始值
  2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化

##### 列表初始值还是元素数量？

- 在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。
- 如果用的是圆括号，可以说提供的值是用来构造vector对象的。
- 如果用的是花括号，可以表述成我们想列表初始化该vector对象。

```c++
vector<int> v1(10);		// v1有10个元素，每个的值都是0
vector<int> v2{10};		// v2有1个元素，该元素的值是10

vector<int> v3(10,1);	//v3有10个元素，每个值都是1
vector<int> v4{10,1};	//v4有2个元素，值分别是10和1
```

- 另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就有可能是给定容量值

```c++
vector<string> v5{"hi"};	//列表初始化：v5有一个元素
vector<string> v6("hi");	//错误：不能使用字符串字面值构建vector对象;
vector<string> v7{10};		//v7有10个默认初始化的元素
vector<string> v8{10,"hi"};	//v8有10个值为"hi“的元素
```

#### 3.3.2 向vector对象中添加对象

- 利用vector的成员函数`push_back`向其中添加元素
- vector对象能高效增长，那么在定义vector对象的时候设定其大小也就没什么必要了。
- 另外，如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。

#### 3.3.3 其他常用vector操作

- vector支持的部分操作：

| 操作             | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| v.empty()        | 如果v不含有任何元素，返回真；否则返回假                      |
| v.size()         | 返回v中元素的个数                                            |
| v.push_back(t)   | 向v的尾端添加一个值为t的元素                                 |
| v[n]             | 返回v中第n个位置上元素的引用                                 |
| v1 = v2          | 用v2中元素的拷贝替换v1中的元素                               |
| v1 = {a,b,c,...} | 用列表中元素的拷贝替换v1中的元素                             |
| v1 == v2         | v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| v1 != v2         |                                                              |
| <,<=,>,>=        | 以字典序进行比较                                             |

- 各个相等性运算符和关系运算符也与string的相应运算符功能一致。
- 只有当元素的值可比较时，vector对象才能被比较。一些类，如string等，确实定义了自己的相等性运算符和关系运算符；另外一些，如Sale_item类支持的运算并不支持相等性判断和关系运算符等操作。因此，不能比较两个vector<Sale_item>对象。

##### 不能用下标形式添加元素

- 不能用下标形式添加元素，正确的方法是使用push_back
- 试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。
- 确保下标合法的一种有效手段就是尽可能使用范围for语句。

### 3.4 迭代器介绍

- 我们已经知道可以使用下标运算符来访问string对象的字符或vector对象的元素，还有另外一种更通用的机制也可以实现同样的目的，这就是迭代器。
- 所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。
- 严格来说，string对象不属于容器类型，但是string支持很多与容器类型类似的操作。vector支持小标运算符，这点和string一样；string支持迭代器，这也和vector是一样的。
- 迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器要么指向某个元素，要么指向容器中尾元素的下一位置；其他所有情况都属于无效。

#### 3.4.1 使用迭代器

- 和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。
  - begin成员返回指向第一个元素（或第一个字符）的迭代器。
  - end成员返回指向容器（或string对象）的尾元素的下一个位置。
  - 特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。都是尾后迭代器。

##### 迭代器运算符

- 标准容器迭代器的运算符：

  | 运算符         | 说明                                                     |
  | -------------- | -------------------------------------------------------- |
  | `*iter`        | 返回迭代器iter所指元素的引用                             |
  | `iter->mem`    | 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem |
  | `++iter`       | 令iter指示容器中的下一个元素                             |
  | `--iter`       | 令iter指示容器中的上一个元素                             |
  | `iter1==iter2` | 判断两个迭代器是否相等                                   |
  | `iter1!=iter2` | 判断两个迭代器是否不相等                                 |

  

- 例子：第一个单词全为大写

  ```c++
  for (auto it =str.begin();it!=str.end()&&!isspace(*it);++it)
          *it = toupper(*it);
  ```

  > ​	关键概念：泛型编程
  >
  > ​	我们会对for循环中使用!=而非<进行判断有点儿奇怪，因为这种编程风格在标准库提供的所有容器上都有效。

##### 迭代器类型

- 对于拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型:

```c++
vector<int>::iterator it;		//it能读写vector<int>元素
string::iterator it2;		//it2能读写string对象中的字符

vector<int>::const_iterator it3;	//it3只能读元素，不能写元素
string::const_iterator it4;		//it4只能读字符，不能写字符
```

- const_iterator和常量指针差不多，能读取但不能修改他所指的元素值。
- 如果vector对象或string对象是一个常量，只能使用const_iterator
- 如果vector对象或string对象不是常量，那么即能使用iterator也能使用const_iterator。

##### begin和end运算符

- begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator:

```c++
vector<int> v;
cosnt vector<int> cv;
auto it1 = v.begin();		//it1的类型是vector<int>::iterator
auto it2 = cv.begin();		//it2的类型是vector<int>::const_iterator
```

- 有时这种默认的行为并非我们所要。如果对象只需读操作最好使用常量类型。为了便于专门得到const_iterator类型的返回值，c++11新标准引入了两个新函数，分别是cbegin和cend:

  ```c++
  auto it3 = v.cbegin();	//it3的类型是vector<int>::const_iterator
  ```

- 不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator

##### 结合解引用和成员访问操作

- 解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能进一步访问它的成员。

- 例如，对于一个由字符串组成的vector对象来说，要想检查其元素是否为空：

  ```c++
  (*it).empty();//注意，圆括号必不可少。解引用it，然后调用结果对象的empty成员
  *it.empty();	//错误，试图访问it的名为empty的成员，但it是个迭代器，没有empty成员
  ```

- 为了简化上述表达式，c++语言定义了**箭头运算符(->)。**箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it->mem和(*it).mem表达的意思相同。

##### 某些对vector对象的操作会使迭代器失效

- 谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。
- 虽然vector对象可以动态地增长，但是也会有一些副作用。
  - 不能在范围for循环中向vector对象添加元素
  - 任何一种可能改变vector对象容器的操作，比如push_back，都会使vector对象的迭代器失效。

#### 3.4.3 迭代器运算

- 迭代器支持的运算：

  | 运算           | 含义                                                         |
  | -------------- | ------------------------------------------------------------ |
  | `iter+n`       | 迭代器加上一个整数值扔得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。 |
  | `iter-n`       | 迭代器减去一个整数值扔得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。 |
  | `iter+=n`      | 迭代器加法的复合赋值语句，将iter加n的结果赋给iter            |
  | `iter-=n`      | 迭代器减法的复合赋值语句，将iter减n的结果赋给iter            |
  | `iter1-iter2`  | 两个迭代器相减的结果是它们之间的距离，参与运算的两个迭代器必须指向的是同一个容器中的元素尾元素的下一个位置 |
  | `>、>=、<、<=` | 迭代器的关系运算符，比较位置关系                             |

##### 迭代器的算术运算

- 指向某vector对象中间位置的元素：`auto mid = vi.begin()+vi.size()/2;`
- 某vector对象的size大小：`vi.end()-vi.begin();`

- 只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。其可正可负。

### 3.5 数组

- 数组也是存放类型相同的对象的容器，数组的大小确定不变，不能随意向数组中增加元素。
- 如果不清楚元素的确切个数，请使用vector

#### 3.5.1 定义和初始化内置数组

- 数组是一种复合类型。数组的声明形如a[d]，其中a是数组的名字，d是数组的维度。维度说明了数组中元素的个数，因此必须大于0。

- 编译的时候维度应该是已知的，也就是说，维度必须是一个常量表达式：

  ```c++
  	unsigned cnt = 42;		//不是常量表达式
  	constexpr unsigned sz = 42;	//常量表达式
  	int arr[10];		//含有10个整数的数组
  	int *parr[sz];		// 含有42个整型指针的数组
  	string bad[cnt];	// 错误：cnt不是常量表达式
  	string strs[get_size()];// 当get_size是constexpr时正确；否则错误
  
  ```

- 默认情况下，数组的元素被默认初始化

##### 显示初始化数组元素

- 可以对数组的元素进行列表初始化，此时允许忽略数组的维度。
  - 如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来
  - 如果指明了维度，那么初始值的总数量不应该超出指定的大小。
  - 如果维度比提供的初始值数量大，则用提供的初始值初始化考前的元素，剩下的被初始化成默认值

```c++
	const unsigned sz = 3;
	int ial[sz] = {0, 1, 2};		//含有3个元素的数组
	int a2[] = {0, 1, 2};			// 维度是3的数组
	int a3[5] = {0, 1, 2};			// 等价于a3[] = {0, ,1 , 2, 0, 0}
	string a4[3] = {"hi", "bye"};	// 等价于a4[] = {"hi", "bye", ""}
	int a5[2] = {0, 1, 2};			// 错误：初始值过多

```

##### 字符数组的特殊性

- 字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。但注意字符串字面值的结尾处还有一个空字符。

```c++
	char a1[] = {'c','+','+'};		// 列表初始化，没有空字符
	char a2[] = {'c','+','+','\0'};	// 列表初始化，含有显式的空字符
	char a3[] = "C++";				// 自动添加表示字符串结束的空字符
	const char a4[6] = "Daniel";	// 错误：没有空间可存放空字符

```

- a3和a2的维度一样是4，尽管字符串字面值“Daniel”看起来只有6个字符，但是数组的大小必须至少是7，6个位置存放字面值的内容，另外1个存放结尾处的空字符。

##### 不允许拷贝和赋值

- 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

  ```c++
  int a[] = {0, 1, 2};
  int a2[] = a;		//错误：不允许使用一个数组初始化另一个数组
  a2 = a;				// 错误：不能把一个数组直接赋值给另一个数组	
  ```

##### 理解复杂的数组声明

```c++
	int *ptrs[10];			//ptrs是含有10个整型指针的数组
	int &refs[10] = /* ? */ // 错误：不存在引用的数组
	int (*Parray)[10] = &arr;	// Parray指向一个含有10个整数的数组
	int (&arrRef)[10] = arr;	// arrRef引用一个含有10个整数的数组

```

- 对于ptrs来说，从右向左理解其含义比较简单
- 对于Parray来说，由内向外阅读的顺序来理解

#### 3.5.2 访问数组元素

- 数组的元素也能使用范围for语句或下标运算符来访问。索引从0开始。

- 在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。

- 当需要遍历数组的所有元素时，最好的办法是使用范围for语句。

  ```c++
  for (auto i : scores)		//scores是一个数组
  	cout<<i<<" ";
  cout<<endl;
  ```

- 因为维度是数组类型的一部分，所以系统知道scores中有多少个元素，使用范围for语句可以减轻人为控制遍历过程的负担。

#### 3.5.3 指针和数组

- 数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地支付就能得到执行那个该元素的指针：

  ```c++
  string nums[] = {"one", "two", "three"};//数组的元素是string对象
  string *p = &nums[0];		//p指向nums的第一个元素
  string *p2 = nums;		//等价于p2 = &nums[0];使用数组名时，编译器会自动地将其替换为一个指向数组首元素地指针
  ```

- 在一些情况下，数组的操作实际上是指针的操作

  - 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组：

    ```c++
    int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    auto ia2(ia);		//ia2是一个整型指针，指向ia的第一个元素
    ia2 = 42;		//错误：ia2是一个指针，不能用int值给指针赋值
    ```

  - 尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式：

    ```c++
    auto ia2(&ia[0]);		//显然ia2的类型是int*
    ```

  - 当使用decltype关键字时上述转换不会发生

    ```c++
    decltype(ia) ia3={0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    ```


##### 指针也是迭代器

- vector和string的迭代器支持的运算，数组的指针全部支持。

```c++
	int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	int *p = arr;	//p指向arr的第一个元素
	++p;			//p指向arr[1]
	int *b = arr;
	int *e = &arr[10];	//指向arr尾元素的下一位置的指针
	for (b = arr; b != e; ++b)
		cout<<*b<<endl;

```

##### 标准库函数begin和end

- 通过头文件iterator中的begin和end函数，能让上述遍历指针使用更简单、更安全。

  - begin函数返回指向ia首元素的指针

  - end函数返回指向ia尾元素下一位置的指针

    ```c++
    	int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    	int *beg = begin(ia);		//指向ia首元素的指针
    	int *last = end(ia);		//指向arr尾元素的下一位置的指针
    
    ```

  - 特别要注意，尾后指针不能执行解引用和递增操作

##### 指针运算

- 给一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置

- 两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素：

  ​	`auto n =end(arr)-begin(arr);`

  - 两个指针相减的结果的类型是一种名为prtdiff_t的标准库类型，和size_t一样，也定义在cstddef头文件中的机器相关的类型。且是一种带符号类型。

- 只要两个指针指向同一个数组的元素，就能利用关系运算符对其进行比较。

##### 下标和指针

- 使用数组的名字其实用的是一个指向数组首元素的指针。
- 对数组执行下标运算其实是对指向数组的元素的指针执行下标运算：

```C++
	int i = ia[2];		//ia转换成指向数组首元素的指针
						//ia[2]得到(ia+2)所指的元素
	int *p = ia;		//p指向ia的首元素
	i = *(p+2);			//等价于i = ia[2];

```

- 只要指针指向的是数组中的元素，都可以执行下标运算：

```c++
int *p = &ia[2];	//p指向索引为2的元素
int j = p[1];		//p[1]等价于*(p+1),就是ia[3]表示的那个元素
int k = p[-2];		//p[-2]是ia[0]表示的那个元素
```

- 虽然标准库类型vector和string也能支持下标运算，但使用的下标必须是无符号类型。而数组的下标运算（即内置的下标运算）无此要求。

#### 3.5.4 C风格字符串

- C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法，即**书写的字符串存放在字符数组中并以空字符结束**。一般利用指针来操作这些字符串。

##### C标准库String函数

- 在C++中，该组函数定义在cstring头文件中

| 函数            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| strlen(p)       | 返回p的长度，空字符不计算在内                                |
| strcmp(p1, p2)  | 比较p1和p2的相等性。如果p1==p2，返回0;如果p1>p2，返回一个正值;如果p1<p2，返回一个负值 |
| strcat(p1 , p2) | 将p2附加到p1之后，返回p1                                     |
| strcpy(p1, p2)  | 将p2拷贝给p1，返回p1                                         |

- 传入此类函数的指针必须指向以空字符作为结束的数组：

  ```c++
  	char ca[] = {'C', '+', '+'};	//不以空字符结束
  	cout<<strlen(ca)<<endl;			//严重错误：ca没有以空字符结束
  
  ```

  - strlen函数将有可能沿着ca在内存中的位置不断向前寻找，知道遇到空字符才停下来。

##### 比较字符串

- 比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符：

  ```c++
  string s1 = "A string example";
  string s2 = "A different string";
  if (s1 < s2)
  ```

- 若使用这些运算符比较C风格字符串上，实际比较的将是指针而非字符串本身：

  ```c++
  const char ca1[] = "A string example";
  const char ca2[] = "A different string";
  if (ca1<ca2)	//未定义的：试图比较两个无关地址	
  ```
  - 要想比较C风格字符串需要调用strcmp函数，此时比较的就不再是指针了。

  ```c++
  if (strcmp(ca1,ca2)<0);
  ```

#### 3.5.5 与旧代码的接口

> 在C++程序标准库出现之前，很多程序是使用C语言或其他语言的接口程序写的。因此，现代的C++程序不得不与那些充满了数组和C风格字符串的代码衔接。

##### 混用string对象和C风格字符串

- 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

  - 允许使用以空字符结束的字符数组来初始化strng对象或为string对象赋值。
  - 允许作为string对象的加法运算对象

- 上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，而无法直接用string对象来替代它。例如，不能用string对象直接初始化指向字符的指针。为此，string专门提供了一个名为c_str的成员函数：

  ```c++
  string s("Hello World");
  char *str = s;		//错误：不能用string对象初始化char *
  const char *str = s.c_str();		//正确
  ```

- c_str函数的返回值是一个C风格的字符串。即函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象一样。

- 结果指针的类型是const char *，从而确保我们不会同过指针来改变字符数组的内容。

##### 使用数组初始化vector对象

- 允许使用数组来初始化vector对象。只需指明要拷贝区域的首元地址和尾后地址就可以了：

  ```c++
  int int_arr[] = {0, 1, 2, 3, 4, 5};
  vector<int> ivec(begin(int_arr),end(int_arr));
  ```

#### 3.6 多维数组

- 严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。

- 例如：`int arr[3][4];`它定义了一个大小为3的数组，该数组的每个元素都是含有4个整数的数组。

##### 多维数组的初始化

- 允许使用花括号括起来的一组值初始化多维数组。

  ```c++
  int ia[3][4] = {
  	{0, 1, 2, 3},
  	{4, 5, 6, 7},
  	{8, 9,10, 11}
  };
  ```

- 其中内层嵌套着的花括号并非必需的。

  ```c++
  int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10};
  ```

- 仅仅想初始化每一行的第一个元素

  ```c++
  int ia[3][4] = {{0},{4},{8}};
  ```

- 若去掉内层括号，结果就是初始化第一行的元素。

  ```c++
  int ia[3][4] = {0, 3, 6, 9};
  ```

##### 使用范围for语句处理多维数组

```c++
size_t cnt = 0;
for (auto &row : ia)
	for (auto &col : row) {
			col = cnt;
			++cnt;
	}
```

- 第一个for循环遍历ia所有的元素，这些元素是大小为4的数组，因此row的类型就是含有4个整数的数组的引用。第二个for循环遍历那些4元素数组中的某一个。

- 为了避免数组被自动转成指针，我们仍然使用引用类型来遍历，即使不改变数组的元素。

  ```c++
  for (const auto &row :ia)
  	for (auto col ; row)
  		cout <<col <<endl;
  ```

- 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

##### 指针和多维数组

- 当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

- 由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：

  ```c++
  int ia[3][4];
  int (*p)[4] = ia;		// p指向含有4个整数的数组
  p = &ia[2];				// p指向ia的尾元素
  ```

- 在上述声明中，圆括号必不可少：

  ```c++
  int *ip[4];		// 整型指针的数组
  int (*ip)[4];	// 指向含有4个整数的数组
  ```

- 随着C++11新标准的提出，通过使用auto或者decltype就能尽可能地避免在数组前面加上一个指针类型了：

  ```c++
  	int ia[3][4] = {
  		{0, 1, 2, 3},
  		{4, 5, 6, 7},
  		{8, 9, 10, 11},
  	};
  
  	for (auto p = ia; p!=ia + 3; ++p) {
  		for (auto q = *p; q != *p + 4; q++)
  			cout<<*q<<' ';
  		cout<<endl;
  	}
  ```

  - *p是一个含有4个整数地数组，像往常一样，数组名被自动地转换成指向该数组首元素地指针。内层for循环不断迭代直到处理完了当前内层数组的所有元素为止。

- 也可使用begin和end同样实现：

  ```c++
  	int ia[3][4] = {
  		{0, 1, 2, 3},
  		{4, 5, 6, 7},
  		{8, 9, 10, 11},
  	};
  
  	for (auto p = begin(ia); p != end(ia); ++p) {
  		for (auto q = begin(*p); q != end(*p); ++q)
  			cout<<*q<<' ';
  		cout<<endl;
  	}
  
  ```

  

