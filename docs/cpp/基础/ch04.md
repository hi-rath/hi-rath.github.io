## 第4章 表达式

### 4.1 基础

#### 4.1.1 基本概念

##### 重载运算符

- C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。
- 当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为重载运算符。

##### 左值和右值

- 在C++中，左值和右值是用于区分表达式的两个基本类别。一个表达式的分类取决于其是否是左值或右值，这对于语言的类型系统和内存系统都非常重要。

  - **左值**是指一个可以出现在赋值语句的左侧的表达式，也就是可以被修改的表达式。左值表示一个对象的内存地址，它有一个固定的、具体的内存位置。例如，变量、数组元素和类成员都是左值。**左值引用**是指对左值的引用，它可以绑定到一个左值或一个左值引用。
  - **右值**是指一个不能出现在赋值语句的左侧的表达式，也就是不能被修改的表达式。右值表示一个临时的、匿名的内存位置，它没有名字或地址。例如，字面值常量、临时对象和表达式结果都是右值。**右值引用**是指对右值的引用，它只能绑定到一个右值或一个右值引用。

- 左值和右值的区分非常重要，因为它们具有不同的语义和用途：

  1. 左值可以出现在赋值语句的左侧，因此它们可以被修改。
  2. 右值不能出现在赋值语句的左侧，因此它们不能被修改。
  3. 左值可以绑定到左值引用或右值引用，右值只能绑定到右值引用或 const 左值引用。
  4. 右值通常表示临时的、匿名的值，它们在表达式计算结束后就会被销毁。
  5. 左值通常表示具有持久性的值，它们在表达式计算后仍然存在于内存中。

  在 C++11 中，右值引用和移动语义的引入使得右值具有了更多的用途。右值引用可以被用来实现移动构造函数和移动赋值运算符，这可以提高对象的构造和赋值的性能。移动语义允许将对象的所有权从一个对象转移给另一个对象，这可以避免不必要的内存分配和复制操作。因此，在使用类似于字符串、容器等的类时，区分左值和右值非常重要。

```c++
int a = 10;		//a是左值，10是右值
int b = a;		//a是左值，b是左值
int c = a + b;	//a+b是右值，c是左值
int &d = a;		//a是左值，d是左值引用
int &&e = a + b;//a+b是右值，e是右值引用 
```

- 在上面的示例代码中，变量a和b都是左值，因为它们可以被赋值。表达式a + b是右值，因为它不能被赋值。变量d是左值引用，因为它引用了一个左值变量a。变量e是右值引用，因为它引用了一个右值表达式a + b

- 当我们使用类似于字符串、容器等的类时，左值和右值的区分非常重要。

  举个例子，假设有一个函数需要接收一个字符串并将其存储在一个容器中，代码如下：

  ```c++
  void addStringToVector(const std::string& str, std::vector<std::string>& vec) {
      vec.push_back(str);
  }
  ```

  在上述代码中，`str` 是一个左值引用，因为我们需要将其作为函数参数传递，并将其存储在容器中。如果我们将右值传递给该函数，编译器会发出一个警告，因为右值无法修改，无法存储到容器中。

  如果我们尝试将一个右值传递给该函数，如下所示：

  ```c++
  addStringToVector("Hello, World!", myVector);
  ```

  编译器将抛出一个错误，因为我们无法将一个右值绑定到一个左值引用参数上。

  为了解决这个问题，我们可以使用右值引用参数来接收传入的右值，从而避免将其存储在容器中之前进行复制操作。改进后的代码如下：

  ```c++
  void addStringToVector(std::string&& str, std::vector<std::string>& vec) {
      vec.push_back(std::move(str));
  }
  ```

  在上述代码中，我们使用了右值引用来接收传入的字符串，并在将其存储在容器中之前使用 `std::move()` 将其转移。这将避免不必要的字符串复制操作，从而提高了代码的性能。现在我们可以使用一个右值来调用该函数：

  ```c++
  addStringToVector("Hello, World!", myVector);
  ```

  这将正常工作，并且不会抛出编译器错误。

#### 4.1.3 取值顺序

- 在大多数情况下，不会明确指定求值的顺序。对于那些没有指定执行书顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。

- 举个简单的例子，`<<`运算符没有明确规定何时以及如何对运算符对象求职，因此下面的输出表达式是未定义的：

  ```c++
  int i = 0;
  cout << i <<" " << ++i << endl;	//未定义的
  ```

  因为程序是未定义的，所以我们无法推断它的行为。编译器可能先求++i的值再求i的值。

- 有4种运算符明确规定了运算符对象的求值顺序。

  - 逻辑与（&&）运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。
  - 逻辑或（||）、条件（?:）、逗号（,）

##### 求值顺序、优先级、结合律

- 运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中：
  - 优先级规定，g()的返回值和h()的返回值相乘。
  - 结合律规定，f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加。
  - 但对于这些函数的调用顺序没有明确规定。

> 建议：处理复合表达式
>
> ​	1.拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
>
> ​	2.如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，表达式*++iter中，先求递增运算，再解引用运算

### 4.2 算术运算符

- 算术运算符的运算对象和求值结果都是右值。

- 运算符：+	功能：一元正号	用法：+ expr
- 运算符：-     功能：一元负号    用法：- expr

- 当一元正号（或负号）运算符作用于一个指针或者算术值时，返回运算对象值的一个（提升后的）副本。

```c++
int i = 1024;
int k = -i;		// k是-1024
bool b = true;
bool b2 = -b;		// b2是true
```

- 对大多数运算符来说，布尔类型的运算对象将被提升为int类型。布尔变量b的值为真，参与运算时将被提升成整数值1，对它求负的结果是-1。显然这个初始值不等于0，所以b2的值是真。
- 运算符%为取模运算，参与取余运算的运算对象必须是整数类型
- m%n的结果符号与m的符号相同。

### 4.3 逻辑和关系运算符

- 关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。这两类运算符的运算对象和求值结果都是右值。

##### 逻辑运算符

- 先求左侧运算对象的值再求右侧运算对象的值，这种策略称为**短路求值**

```c++
	string s1("hello world.");
	string s2;
	string s3("this is a cpp file.");
	string s4(".djsadke");
	vector<string> text{s1,s2,s3,s4};

	for (const auto &s : text) 
	{
		cout << s;
		if (s.empty() || s[s.size() - 1] == '.')
			cout << endl;
		else
			cout << " ";
	}
```

- s被声明了对常量的引用。因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝；又因为不需要对string对象做写操作，所以s被声明成对常量的引用。

##### 关系运算符

- 因为关系运算符的求值结果是布尔值，所以将几个关系运算符连写在一起会产生意想不到的结果：

  ```c++
  if (i < j < k)	// 拿i < j 的布尔值结果和k比较，若k > 1则为真
  ```

- 正确的写法为：

  ```c++
  if (i < j && j < k)
  ```


##### 相等性测试与布尔字面值

- 如果想测试一个算术对象或指针对象的真值，最直接的方法就是将其作为if语句的条件：

  ```c++
  if (val) { }		// 如果val是任意的非0值，条件为真
  if (!val) { } 		// 如果val是0，条件为真
  ```

- 有时会写成如下形式：

  ```c++
  if (val == true) { } // 只有当val等于1时条件为真
  ```

  - 若val不是布尔类型，只有当val等于1时为真
  - 若val是布尔类型，则直接判断
  - 因为在比较之前首先会把true转换成val的类型。等价于：

  ```c++
  if (val == 1) { }	//当val不是布尔值时
  ```

- 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。

### 4.4 赋值运算符

- 赋值运算符的左侧运算对象必须是一个可修改的左值。

```c++
int i = 0, j = 0, k = 0; //初始化而非赋值
const int ci = i; 	// 初始化而非赋值
```

- 下面的赋值语句都是非法的：

```c++
1024 = k;	//错误：字面值是右值
i + j = k; //错误：算术表达式是右值
ci = k;		//错误：ci是常量（不可修改的）左值
```

- 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型：

```c++
k = 0;		//结果：类型是int,值是0
k = 3.14159	//结果：类型是int,值是3
```

##### 赋值运算满足右结合律

- 靠右的赋值运算会作为靠左的赋值运算的右侧运算对象。

```c++
int ival, jval;
ival = jval = 0;	//正确：都被赋值为0
```

##### 赋值运算优先级较低

- 通常需要给赋值部分加上括号使其符合我们的原意：

  ```c++
  // 繁琐的写法
  int i = get_value();
  while (i != 42) {
  	i = get_value();
  }
  ```

- 可将上述代码以更简单的形式表达出来：

  ```c++
  int i;
  while ((i = get_value()) != 42) {
  
  }
  ```

- 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。

### 4.5 递增和递减运算符

- 递增运算符（++）和递减运算符（--）为对象的加1和减1操作提供了一种简洁的书写形式。
- 这两个运算符可应用于迭代器，因为很多迭代器本身不支持算术运算，所以此时递增和递减运算符除了书写简洁外还是必须的。
- 递增和递减运算符有两种形式：前置版本和后置版本。

> 建议：除非必须，否则不用递增递减运算符的后置版本
>
> ​	前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费
>
> ​	对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的容器类型，这种额外的工作就消耗巨大了。

##### 在一条语句中混用解引用和递增运算符

```c++
cout << *iter++ << endl;
// 等价的
cout << *iter <<endl;
iter ++;
```

##### 运算对象可按任意顺序求值

- 如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。

```c++
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
	*it = toupper(*it);
```

- 如果用一个看似等价的while循环替代：

```c++
while (beg != s.end() && !isspace(*beg))
	*beg = toupper (*beg ++);	//错误：该赋值语句未定义
```

- 问题在于：赋值运算符左右两端的运算对象都用到了beg，并且右侧的运算对象还改变了beg的值，所以该赋值语句是未定义的。

- 编译器可能按照下面的任意一种思路处理该表达式：

  ```c++
  *beg = toupper(*beg);			//如果先求左侧的值
  *(beg + 1) = toupper(*beg);		//如果先求右侧的值
  ```


### 4.6 成员访问运算符

- 点运算符和箭头运算符都可用于访问成员。

  - 点运算符获取类对象的一个成员。

  - 箭头运算符与点运算符有关，常用于指针访问，表达式`ptr->mem`等价于`(*ptr).mem`

    ```c++
    string s1 = "a string", *p = &s1;
    auto n = s1.size();		//运行string对象s1的size成员
    n = (*p).size();		//运行所指对象的size成员
    n = p->size();			//等价于(*p).size()
    ```

  - 因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端加上括号

    ```C++
    *p.size();		//错误：p是一个指针，它没有名为size()的成员
    ```

- 箭头运算符作用于一个指针类型的运算对象，结果是一个左值。

- 点运算符分为两种情况：

  1. 如果成员所属的对象是左值，那么结果是左值。
  2. 反之，如果成员所属的对象是右值，那么结果是右值。

### 4.7 条件运算符

- 条件运算符（?:）允许我们把简单的if-else逻辑嵌入到单个表达式当中

- 按照如下形式：

  `cond?expr1:epxr2;`

- 例如判断成绩是否合格：

  ```c++
  string finalgrade = (grade < 60)?"fail":"pass";
  ```

##### 在输出表达式中使用条件运算符

- 条件运算符的优先级非常低，常需要括号提高优先级。

- 如果写这些语句时没有括号会产生意想不到的结果：

  ```c++
  cout << ((grade < 60)?"fail":"pass");//输出pass或者fail
  cout << (grade < 60) ? "fail" : "pass";//输出1或者0
  cout << grade < 60 ?"fail":"pass";	//错误：试图比较cout和60
  
  ```

  - 在第二条表达式中，grade和60的比较结果是<<运算符的运算对象。如果grade<60为真输出1，否则输出0。<<运算符的返回值是cout，接下来cout作为条件运算符的条件。等价于：

    ````c++
    cout <<(grade < 60);	//输出0或1
    cout ? "fail" : "pass";	//根据cout的值是true还是false产生对应的字面值
    ````

  - 第三条表达式等价于：

    ```c++
    cout << grade;
    cout < 60 ? "fail" : "true";	//比较cout和60
    ```

### 4.8 位运算符

- 位运算符作用于整数类型的运算对象，并把运算对象看成是二进制的集合。
- 一种名为bitset的标准库类型可以表示任意大小的二进制位集合。

| 运算符 |  功能  |      用法      |
| :----: | :----: | :------------: |
|   `    | 位求反 |     `expr      |
|   <<   |  左移  | expr1 << expr2 |
|   >>   |  右移  | expr1 >> expr2 |
|   &    |  位与  |  expr & expr   |
|   ^    | 位异或 |  expr ^ epxr   |
|   \|   |  位或  |  expr \| expr  |

- 如果运算对象是小整型，则它的值会被自动提升成较大的整数类型。
- 建议仅将位运算符用于处理无符号类型。

##### 移位运算符

- <<运算符和>>运算符的内置含义是对其运算对象执行基于二进制位的移动操作。
- 首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。
  - 右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。
  - 移出边界之外的位就被舍弃掉了
  - 左移运算符在右侧插入值为0的二进制位。右移运算符的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值位0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。

##### 位求反运算符

- 将运算对象逐位求反后生成一个新值，将1置为0、将0置为1

##### 位与、位或、位异或运算符

- 位与运算符：如果两个运算对象的对应位置都是1则运算结果中该位为1，否则为0。
- 位或运算符：如果两个运算对象的对应位置至少有一个为1则运算结果中该位为1，否则为0。
- 位异或运算符：如果两个运算对象的对应位置有且只有一个为1则运算结果中该位为1，否则为0。

##### 使用位运算符

- 测试是否通过案例：

```c++
	unsigned long quiz1 = 0;	// 把这个值当成是位的集合来使用
	unsigned long ul1 = 1;		// 定义一个整数字面值为1的值

	// 位运算符优先级高于赋值运算符
	ul1  = ul1 << 27;		// 生成一个值，该值只有第27位为1
	quiz1 |= ul1;			// 进行位或运算，表示学生27通过了测验
	bool status = quiz1 & ul1;	// 学生27是否通过了测验？
	cout << (int)status <<endl;	// 如果quiz1的第27位是1，计算结果就是非0，否则结果是0。

```

### 4.9 sizeof运算符

- sizeof运算符返回一条表达式或一个类型名字所占的字节数。所得的值是一个size_t类型。

- 运算符的运算对象有两种形式：

  `sizeof (type)`

  `sizeof expr`

```c++
Sales_data data, *p;
sizeof(Sales_data);		//存储Sales_data类型的对象所占的空间大小
sizeof data;			//data的类型的大小，即sizeof(Sales_data)
sizeof p;				//指针所占的空间大小
sizeof *p;				//p所指类型的空间大小，即sizeof(Sales_data)
sizeof data.revenue;	//Sales_data的revenue成员对应类型的大小
sizeof Sales_data::revenue;		//另一种获取revenue大小的方式
```

- `sizeof *p·`等价于`sizeof (*p)`

### 4.10 逗号运算符

- 逗号运算符经常被用在for循环当中：

  ```c++
  for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
  ```

- 逗号表达式的优先级最低：

  ```
  someValue ? ++x,++y : --x, --y
  //等价于
  (someValue ? ++x,++y : --x), --y
  ```

  

### 4.11 类型转换

#### 4.11.3 显示转换

- 有时我们希望显式地将对象强制转换成另外一种类型。例如，如果想在下面地代码中执行浮点数除法：

  ```c++
  int i, j;
  double slope = i/j;
  ```

  就要使用某种方法将i和/或j显式地转换成double，这种方法称为强制类型转换。

##### 命名的强制类型转换

- 一个命名的强制类型转换具有如下形式：

  `cast-name<type>(expression);`

  其中，type是转换的目标类型而expression是要转换的值。

  cast-name是`static_cast`、`dynamic_cast`、`const_cast`、`reinterptet_cast`中的一种。

##### static_cast

- 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

  ```c++
  //进行强制类型转换以便执行浮点数除法
  double slope = static_cast<double>(j)/i;
  ```

- 当需要把一个较大的算术类型赋值给较小的类型时，可以使用强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息：但是当我们执行了显示的类型转换后，警告信息就会被关闭了。

- static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*指针中的值：

  ```c++
  double d = 3.1415;
  void *p = &d;
  double *dp = static_cast<double*>(p);
  ```

  必须确保转换后所得的类型就是指针所指的类型。

##### const_cast

- const_cast只能改变运算对象的底层const

  ```c++
  const char *pc;
  char *p = const_cast<char*>(pc);//正确：但是通过p写值是未定义的行为
  ```

- 对于将常量对象转换成非常量对象的行为，称为“去掉const性质”。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。但如果对象是一个常量，我们仍然不能通过去掉const性质进行写操作。

- 只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。

- 不能用const_cast改变表达式的类型：

  ```c++
  const char *cp;
  char *q = static_cast<char*>(cp); //错误：static_cast不能转换掉const性质
  char *q = const_cast<char*>(cp);//正确
  static_cast<string>(cp);//正确：转换成string类型
  cosnt_cast<string>(cp);	//错误：const_cast只改变常量属性
  ```

##### reinterpret_cast

- reinterpret_cast可以将任意指针类型转换为另一种指针类型，比如将一个指向整数的指针转换为指向字符的指针。这种类型转换可以用于底层编程或与其他语言交互。

  ```
  int *ip;
  char *pc = reinterpret_cast<char*>(ip);
  ```

  

> 建议：避免强制类型转换
>
> ​		强制类型转换干扰了正常的类型检查，因此我们强烈建议程序员避免使用强制类型转换。

##### 旧式的强制类型转换

- 在早期版本的c++语言中，显示地进行强制类型转换包含两种形式：

  ```
  type (expr);		//函数形式的强制类型转换
  (type) expr;	//c语言风格的强制类型转换
  ```

- 根据所涉及的类型不同，旧式的强制类型转换分别具有与const_cast、static_cast、reinterpret_cast相似的行为。

  ```c++
  char *pc = (char*) ip;//ip是指向整数的指针
  ```

  效果与使用reinterpret_cast一样。

